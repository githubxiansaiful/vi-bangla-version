try {
    let t = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : {},
        e = (new t.Error).stack;
    e && (t._sentryDebugIds = t._sentryDebugIds || {}, t._sentryDebugIds[e] = "30456487-d821-4f92-a334-89d621197854", t._sentryDebugIdIdentifier = "sentry-dbid-30456487-d821-4f92-a334-89d621197854")
} catch (t) {}(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
    [6110], {
        67151: function() {},
        4619: function() {},
        36461: function() {},
        45505: function(t, e, n) {
            "use strict";
            n.d(e, {
                x7: function() {
                    return tc
                },
                Me: function() {
                    return to
                },
                oo: function() {
                    return tp
                },
                RR: function() {
                    return ta
                },
                Cp: function() {
                    return ts
                },
                dr: function() {
                    return td
                },
                cv: function() {
                    return tl
                },
                uY: function() {
                    return tf
                },
                dp: function() {
                    return tu
                }
            });
            let r = ["top", "right", "bottom", "left"],
                i = Math.min,
                o = Math.max,
                l = Math.round,
                f = Math.floor,
                a = t => ({
                    x: t,
                    y: t
                }),
                u = {
                    left: "right",
                    right: "left",
                    bottom: "top",
                    top: "bottom"
                },
                s = {
                    start: "end",
                    end: "start"
                };

            function c(t, e) {
                return "function" == typeof t ? t(e) : t
            }

            function d(t) {
                return t.split("-")[0]
            }

            function p(t) {
                return t.split("-")[1]
            }

            function h(t) {
                return "x" === t ? "y" : "x"
            }

            function g(t) {
                return "y" === t ? "height" : "width"
            }

            function m(t) {
                return ["top", "bottom"].includes(d(t)) ? "y" : "x"
            }

            function y(t) {
                return t.replace(/start|end/g, t => s[t])
            }

            function w(t) {
                return t.replace(/left|right|bottom|top/g, t => u[t])
            }

            function x(t) {
                return "number" != typeof t ? {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0,
                    ...t
                } : {
                    top: t,
                    right: t,
                    bottom: t,
                    left: t
                }
            }

            function v(t) {
                let {
                    x: e,
                    y: n,
                    width: r,
                    height: i
                } = t;
                return {
                    width: r,
                    height: i,
                    top: n,
                    left: e,
                    right: e + r,
                    bottom: n + i,
                    x: e,
                    y: n
                }
            }

            function b(t, e, n) {
                let r, {
                        reference: i,
                        floating: o
                    } = t,
                    l = m(e),
                    f = h(m(e)),
                    a = g(f),
                    u = d(e),
                    s = "y" === l,
                    c = i.x + i.width / 2 - o.width / 2,
                    y = i.y + i.height / 2 - o.height / 2,
                    w = i[a] / 2 - o[a] / 2;
                switch (u) {
                    case "top":
                        r = {
                            x: c,
                            y: i.y - o.height
                        };
                        break;
                    case "bottom":
                        r = {
                            x: c,
                            y: i.y + i.height
                        };
                        break;
                    case "right":
                        r = {
                            x: i.x + i.width,
                            y: y
                        };
                        break;
                    case "left":
                        r = {
                            x: i.x - o.width,
                            y: y
                        };
                        break;
                    default:
                        r = {
                            x: i.x,
                            y: i.y
                        }
                }
                switch (p(e)) {
                    case "start":
                        r[f] -= w * (n && s ? -1 : 1);
                        break;
                    case "end":
                        r[f] += w * (n && s ? -1 : 1)
                }
                return r
            }
            let R = async (t, e, n) => {
                let {
                    placement: r = "bottom",
                    strategy: i = "absolute",
                    middleware: o = [],
                    platform: l
                } = n, f = o.filter(Boolean), a = await (null == l.isRTL ? void 0 : l.isRTL(e)), u = await l.getElementRects({
                    reference: t,
                    floating: e,
                    strategy: i
                }), {
                    x: s,
                    y: c
                } = b(u, r, a), d = r, p = {}, h = 0;
                for (let n = 0; n < f.length; n++) {
                    let {
                        name: o,
                        fn: g
                    } = f[n], {
                        x: m,
                        y: y,
                        data: w,
                        reset: x
                    } = await g({
                        x: s,
                        y: c,
                        initialPlacement: r,
                        placement: d,
                        strategy: i,
                        middlewareData: p,
                        rects: u,
                        platform: l,
                        elements: {
                            reference: t,
                            floating: e
                        }
                    });
                    s = null != m ? m : s, c = null != y ? y : c, p = { ...p,
                        [o]: { ...p[o],
                            ...w
                        }
                    }, x && h <= 50 && (h++, "object" == typeof x && (x.placement && (d = x.placement), x.rects && (u = !0 === x.rects ? await l.getElementRects({
                        reference: t,
                        floating: e,
                        strategy: i
                    }) : x.rects), {
                        x: s,
                        y: c
                    } = b(u, d, a)), n = -1)
                }
                return {
                    x: s,
                    y: c,
                    placement: d,
                    strategy: i,
                    middlewareData: p
                }
            };
            async function A(t, e) {
                var n;
                void 0 === e && (e = {});
                let {
                    x: r,
                    y: i,
                    platform: o,
                    rects: l,
                    elements: f,
                    strategy: a
                } = t, {
                    boundary: u = "clippingAncestors",
                    rootBoundary: s = "viewport",
                    elementContext: d = "floating",
                    altBoundary: p = !1,
                    padding: h = 0
                } = c(e, t), g = x(h), m = f[p ? "floating" === d ? "reference" : "floating" : d], y = v(await o.getClippingRect({
                    element: null == (n = await (null == o.isElement ? void 0 : o.isElement(m))) || n ? m : m.contextElement || await (null == o.getDocumentElement ? void 0 : o.getDocumentElement(f.floating)),
                    boundary: u,
                    rootBoundary: s,
                    strategy: a
                })), w = "floating" === d ? {
                    x: r,
                    y: i,
                    width: l.floating.width,
                    height: l.floating.height
                } : l.reference, b = await (null == o.getOffsetParent ? void 0 : o.getOffsetParent(f.floating)), R = await (null == o.isElement ? void 0 : o.isElement(b)) && await (null == o.getScale ? void 0 : o.getScale(b)) || {
                    x: 1,
                    y: 1
                }, A = v(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
                    elements: f,
                    rect: w,
                    offsetParent: b,
                    strategy: a
                }) : w);
                return {
                    top: (y.top - A.top + g.top) / R.y,
                    bottom: (A.bottom - y.bottom + g.bottom) / R.y,
                    left: (y.left - A.left + g.left) / R.x,
                    right: (A.right - y.right + g.right) / R.x
                }
            }

            function T(t, e) {
                return {
                    top: t.top - e.height,
                    right: t.right - e.width,
                    bottom: t.bottom - e.height,
                    left: t.left - e.width
                }
            }

            function E(t) {
                return r.some(e => t[e] >= 0)
            }
            async function C(t, e) {
                let {
                    placement: n,
                    platform: r,
                    elements: i
                } = t, o = await (null == r.isRTL ? void 0 : r.isRTL(i.floating)), l = d(n), f = p(n), a = "y" === m(n), u = ["left", "top"].includes(l) ? -1 : 1, s = o && a ? -1 : 1, h = c(e, t), {
                    mainAxis: g,
                    crossAxis: y,
                    alignmentAxis: w
                } = "number" == typeof h ? {
                    mainAxis: h,
                    crossAxis: 0,
                    alignmentAxis: null
                } : {
                    mainAxis: h.mainAxis || 0,
                    crossAxis: h.crossAxis || 0,
                    alignmentAxis: h.alignmentAxis
                };
                return f && "number" == typeof w && (y = "end" === f ? -1 * w : w), a ? {
                    x: y * s,
                    y: g * u
                } : {
                    x: g * u,
                    y: y * s
                }
            }

            function L() {
                return "undefined" != typeof window
            }

            function S(t) {
                return D(t) ? (t.nodeName || "").toLowerCase() : "#document"
            }

            function O(t) {
                var e;
                return (null == t || null == (e = t.ownerDocument) ? void 0 : e.defaultView) || window
            }

            function P(t) {
                var e;
                return null == (e = (D(t) ? t.ownerDocument : t.document) || window.document) ? void 0 : e.documentElement
            }

            function D(t) {
                return !!L() && (t instanceof Node || t instanceof O(t).Node)
            }

            function k(t) {
                return !!L() && (t instanceof Element || t instanceof O(t).Element)
            }

            function H(t) {
                return !!L() && (t instanceof HTMLElement || t instanceof O(t).HTMLElement)
            }

            function W(t) {
                return !!L() && "undefined" != typeof ShadowRoot && (t instanceof ShadowRoot || t instanceof O(t).ShadowRoot)
            }

            function F(t) {
                let {
                    overflow: e,
                    overflowX: n,
                    overflowY: r,
                    display: i
                } = z(t);
                return /auto|scroll|overlay|hidden|clip/.test(e + r + n) && !["inline", "contents"].includes(i)
            }

            function M(t) {
                return [":popover-open", ":modal"].some(e => {
                    try {
                        return t.matches(e)
                    } catch (t) {
                        return !1
                    }
                })
            }

            function j(t) {
                let e = $(),
                    n = k(t) ? z(t) : t;
                return "none" !== n.transform || "none" !== n.perspective || !!n.containerType && "normal" !== n.containerType || !e && !!n.backdropFilter && "none" !== n.backdropFilter || !e && !!n.filter && "none" !== n.filter || ["transform", "perspective", "filter"].some(t => (n.willChange || "").includes(t)) || ["paint", "layout", "strict", "content"].some(t => (n.contain || "").includes(t))
            }

            function $() {
                return "undefined" != typeof CSS && !!CSS.supports && CSS.supports("-webkit-backdrop-filter", "none")
            }

            function V(t) {
                return ["html", "body", "#document"].includes(S(t))
            }

            function z(t) {
                return O(t).getComputedStyle(t)
            }

            function N(t) {
                return k(t) ? {
                    scrollLeft: t.scrollLeft,
                    scrollTop: t.scrollTop
                } : {
                    scrollLeft: t.scrollX,
                    scrollTop: t.scrollY
                }
            }

            function Y(t) {
                if ("html" === S(t)) return t;
                let e = t.assignedSlot || t.parentNode || W(t) && t.host || P(t);
                return W(e) ? e.host : e
            }

            function B(t, e, n) {
                var r;
                void 0 === e && (e = []), void 0 === n && (n = !0);
                let i = function t(e) {
                        let n = Y(e);
                        return V(n) ? e.ownerDocument ? e.ownerDocument.body : e.body : H(n) && F(n) ? n : t(n)
                    }(t),
                    o = i === (null == (r = t.ownerDocument) ? void 0 : r.body),
                    l = O(i);
                if (o) {
                    let t = _(l);
                    return e.concat(l, l.visualViewport || [], F(i) ? i : [], t && n ? B(t) : [])
                }
                return e.concat(i, B(i, [], n))
            }

            function _(t) {
                return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null
            }

            function I(t) {
                let e = z(t),
                    n = parseFloat(e.width) || 0,
                    r = parseFloat(e.height) || 0,
                    i = H(t),
                    o = i ? t.offsetWidth : n,
                    f = i ? t.offsetHeight : r,
                    a = l(n) !== o || l(r) !== f;
                return a && (n = o, r = f), {
                    width: n,
                    height: r,
                    $: a
                }
            }

            function X(t) {
                return k(t) ? t : t.contextElement
            }

            function q(t) {
                let e = X(t);
                if (!H(e)) return a(1);
                let n = e.getBoundingClientRect(),
                    {
                        width: r,
                        height: i,
                        $: o
                    } = I(e),
                    f = (o ? l(n.width) : n.width) / r,
                    u = (o ? l(n.height) : n.height) / i;
                return f && Number.isFinite(f) || (f = 1), u && Number.isFinite(u) || (u = 1), {
                    x: f,
                    y: u
                }
            }
            let G = a(0);

            function J(t) {
                let e = O(t);
                return $() && e.visualViewport ? {
                    x: e.visualViewport.offsetLeft,
                    y: e.visualViewport.offsetTop
                } : G
            }

            function K(t, e, n, r) {
                var i;
                void 0 === e && (e = !1), void 0 === n && (n = !1);
                let o = t.getBoundingClientRect(),
                    l = X(t),
                    f = a(1);
                e && (r ? k(r) && (f = q(r)) : f = q(t));
                let u = (void 0 === (i = n) && (i = !1), r && (!i || r === O(l)) && i) ? J(l) : a(0),
                    s = (o.left + u.x) / f.x,
                    c = (o.top + u.y) / f.y,
                    d = o.width / f.x,
                    p = o.height / f.y;
                if (l) {
                    let t = O(l),
                        e = r && k(r) ? O(r) : r,
                        n = t,
                        i = _(n);
                    for (; i && r && e !== n;) {
                        let t = q(i),
                            e = i.getBoundingClientRect(),
                            r = z(i),
                            o = e.left + (i.clientLeft + parseFloat(r.paddingLeft)) * t.x,
                            l = e.top + (i.clientTop + parseFloat(r.paddingTop)) * t.y;
                        s *= t.x, c *= t.y, d *= t.x, p *= t.y, s += o, c += l, i = _(n = O(i))
                    }
                }
                return v({
                    width: d,
                    height: p,
                    x: s,
                    y: c
                })
            }

            function Q(t, e) {
                let n = N(t).scrollLeft;
                return e ? e.left + n : K(P(t)).left + n
            }

            function U(t, e, n) {
                void 0 === n && (n = !1);
                let r = t.getBoundingClientRect();
                return {
                    x: r.left + e.scrollLeft - (n ? 0 : Q(t, r)),
                    y: r.top + e.scrollTop
                }
            }

            function Z(t, e, n) {
                let r;
                if ("viewport" === e) r = function(t, e) {
                    let n = O(t),
                        r = P(t),
                        i = n.visualViewport,
                        o = r.clientWidth,
                        l = r.clientHeight,
                        f = 0,
                        a = 0;
                    if (i) {
                        o = i.width, l = i.height;
                        let t = $();
                        (!t || t && "fixed" === e) && (f = i.offsetLeft, a = i.offsetTop)
                    }
                    return {
                        width: o,
                        height: l,
                        x: f,
                        y: a
                    }
                }(t, n);
                else if ("document" === e) r = function(t) {
                    let e = P(t),
                        n = N(t),
                        r = t.ownerDocument.body,
                        i = o(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth),
                        l = o(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight),
                        f = -n.scrollLeft + Q(t),
                        a = -n.scrollTop;
                    return "rtl" === z(r).direction && (f += o(e.clientWidth, r.clientWidth) - i), {
                        width: i,
                        height: l,
                        x: f,
                        y: a
                    }
                }(P(t));
                else if (k(e)) r = function(t, e) {
                    let n = K(t, !0, "fixed" === e),
                        r = n.top + t.clientTop,
                        i = n.left + t.clientLeft,
                        o = H(t) ? q(t) : a(1),
                        l = t.clientWidth * o.x;
                    return {
                        width: l,
                        height: t.clientHeight * o.y,
                        x: i * o.x,
                        y: r * o.y
                    }
                }(e, n);
                else {
                    let n = J(t);
                    r = {
                        x: e.x - n.x,
                        y: e.y - n.y,
                        width: e.width,
                        height: e.height
                    }
                }
                return v(r)
            }

            function tt(t) {
                return "static" === z(t).position
            }

            function te(t, e) {
                if (!H(t) || "fixed" === z(t).position) return null;
                if (e) return e(t);
                let n = t.offsetParent;
                return P(t) === n && (n = n.ownerDocument.body), n
            }

            function tn(t, e) {
                let n = O(t);
                if (M(t)) return n;
                if (!H(t)) {
                    let e = Y(t);
                    for (; e && !V(e);) {
                        if (k(e) && !tt(e)) return e;
                        e = Y(e)
                    }
                    return n
                }
                let r = te(t, e);
                for (; r && ["table", "td", "th"].includes(S(r)) && tt(r);) r = te(r, e);
                return r && V(r) && tt(r) && !j(r) ? n : r || function(t) {
                    let e = Y(t);
                    for (; H(e) && !V(e);) {
                        if (j(e)) return e;
                        if (M(e)) break;
                        e = Y(e)
                    }
                    return null
                }(t) || n
            }
            let tr = async function(t) {
                    let e = this.getOffsetParent || tn,
                        n = this.getDimensions,
                        r = await n(t.floating);
                    return {
                        reference: function(t, e, n) {
                            let r = H(e),
                                i = P(e),
                                o = "fixed" === n,
                                l = K(t, !0, o, e),
                                f = {
                                    scrollLeft: 0,
                                    scrollTop: 0
                                },
                                u = a(0);
                            if (r || !r && !o) {
                                if (("body" !== S(e) || F(i)) && (f = N(e)), r) {
                                    let t = K(e, !0, o, e);
                                    u.x = t.x + e.clientLeft, u.y = t.y + e.clientTop
                                } else i && (u.x = Q(i))
                            }
                            let s = !i || r || o ? a(0) : U(i, f);
                            return {
                                x: l.left + f.scrollLeft - u.x - s.x,
                                y: l.top + f.scrollTop - u.y - s.y,
                                width: l.width,
                                height: l.height
                            }
                        }(t.reference, await e(t.floating), t.strategy),
                        floating: {
                            x: 0,
                            y: 0,
                            width: r.width,
                            height: r.height
                        }
                    }
                },
                ti = {
                    convertOffsetParentRelativeRectToViewportRelativeRect: function(t) {
                        let {
                            elements: e,
                            rect: n,
                            offsetParent: r,
                            strategy: i
                        } = t, o = "fixed" === i, l = P(r), f = !!e && M(e.floating);
                        if (r === l || f && o) return n;
                        let u = {
                                scrollLeft: 0,
                                scrollTop: 0
                            },
                            s = a(1),
                            c = a(0),
                            d = H(r);
                        if ((d || !d && !o) && (("body" !== S(r) || F(l)) && (u = N(r)), H(r))) {
                            let t = K(r);
                            s = q(r), c.x = t.x + r.clientLeft, c.y = t.y + r.clientTop
                        }
                        let p = !l || d || o ? a(0) : U(l, u, !0);
                        return {
                            width: n.width * s.x,
                            height: n.height * s.y,
                            x: n.x * s.x - u.scrollLeft * s.x + c.x + p.x,
                            y: n.y * s.y - u.scrollTop * s.y + c.y + p.y
                        }
                    },
                    getDocumentElement: P,
                    getClippingRect: function(t) {
                        let {
                            element: e,
                            boundary: n,
                            rootBoundary: r,
                            strategy: l
                        } = t, f = [..."clippingAncestors" === n ? M(e) ? [] : function(t, e) {
                            let n = e.get(t);
                            if (n) return n;
                            let r = B(t, [], !1).filter(t => k(t) && "body" !== S(t)),
                                i = null,
                                o = "fixed" === z(t).position,
                                l = o ? Y(t) : t;
                            for (; k(l) && !V(l);) {
                                let e = z(l),
                                    n = j(l);
                                n || "fixed" !== e.position || (i = null), (o ? !n && !i : !n && "static" === e.position && !!i && ["absolute", "fixed"].includes(i.position) || F(l) && !n && function t(e, n) {
                                    let r = Y(e);
                                    return !(r === n || !k(r) || V(r)) && ("fixed" === z(r).position || t(r, n))
                                }(t, l)) ? r = r.filter(t => t !== l) : i = e, l = Y(l)
                            }
                            return e.set(t, r), r
                        }(e, this._c) : [].concat(n), r], a = f[0], u = f.reduce((t, n) => {
                            let r = Z(e, n, l);
                            return t.top = o(r.top, t.top), t.right = i(r.right, t.right), t.bottom = i(r.bottom, t.bottom), t.left = o(r.left, t.left), t
                        }, Z(e, a, l));
                        return {
                            width: u.right - u.left,
                            height: u.bottom - u.top,
                            x: u.left,
                            y: u.top
                        }
                    },
                    getOffsetParent: tn,
                    getElementRects: tr,
                    getClientRects: function(t) {
                        return Array.from(t.getClientRects())
                    },
                    getDimensions: function(t) {
                        let {
                            width: e,
                            height: n
                        } = I(t);
                        return {
                            width: e,
                            height: n
                        }
                    },
                    getScale: q,
                    isElement: k,
                    isRTL: function(t) {
                        return "rtl" === z(t).direction
                    }
                };

            function to(t, e, n, r) {
                let l;
                void 0 === r && (r = {});
                let {
                    ancestorScroll: a = !0,
                    ancestorResize: u = !0,
                    elementResize: s = "function" == typeof ResizeObserver,
                    layoutShift: c = "function" == typeof IntersectionObserver,
                    animationFrame: d = !1
                } = r, p = X(t), h = a || u ? [...p ? B(p) : [], ...B(e)] : [];
                h.forEach(t => {
                    a && t.addEventListener("scroll", n, {
                        passive: !0
                    }), u && t.addEventListener("resize", n)
                });
                let g = p && c ? function(t, e) {
                        let n, r = null,
                            l = P(t);

                        function a() {
                            var t;
                            clearTimeout(n), null == (t = r) || t.disconnect(), r = null
                        }
                        return ! function u(s, c) {
                            void 0 === s && (s = !1), void 0 === c && (c = 1), a();
                            let {
                                left: d,
                                top: p,
                                width: h,
                                height: g
                            } = t.getBoundingClientRect();
                            if (s || e(), !h || !g) return;
                            let m = f(p),
                                y = f(l.clientWidth - (d + h)),
                                w = {
                                    rootMargin: -m + "px " + -y + "px " + -f(l.clientHeight - (p + g)) + "px " + -f(d) + "px",
                                    threshold: o(0, i(1, c)) || 1
                                },
                                x = !0;

                            function v(t) {
                                let e = t[0].intersectionRatio;
                                if (e !== c) {
                                    if (!x) return u();
                                    e ? u(!1, e) : n = setTimeout(() => {
                                        u(!1, 1e-7)
                                    }, 1e3)
                                }
                                x = !1
                            }
                            try {
                                r = new IntersectionObserver(v, { ...w,
                                    root: l.ownerDocument
                                })
                            } catch (t) {
                                r = new IntersectionObserver(v, w)
                            }
                            r.observe(t)
                        }(!0), a
                    }(p, n) : null,
                    m = -1,
                    y = null;
                s && (y = new ResizeObserver(t => {
                    let [r] = t;
                    r && r.target === p && y && (y.unobserve(e), cancelAnimationFrame(m), m = requestAnimationFrame(() => {
                        var t;
                        null == (t = y) || t.observe(e)
                    })), n()
                }), p && !d && y.observe(p), y.observe(e));
                let w = d ? K(t) : null;
                return d && function e() {
                    let r = K(t);
                    w && (r.x !== w.x || r.y !== w.y || r.width !== w.width || r.height !== w.height) && n(), w = r, l = requestAnimationFrame(e)
                }(), n(), () => {
                    var t;
                    h.forEach(t => {
                        a && t.removeEventListener("scroll", n), u && t.removeEventListener("resize", n)
                    }), null == g || g(), null == (t = y) || t.disconnect(), y = null, d && cancelAnimationFrame(l)
                }
            }
            let tl = function(t) {
                    return void 0 === t && (t = 0), {
                        name: "offset",
                        options: t,
                        async fn(e) {
                            var n, r;
                            let {
                                x: i,
                                y: o,
                                placement: l,
                                middlewareData: f
                            } = e, a = await C(e, t);
                            return l === (null == (n = f.offset) ? void 0 : n.placement) && null != (r = f.arrow) && r.alignmentOffset ? {} : {
                                x: i + a.x,
                                y: o + a.y,
                                data: { ...a,
                                    placement: l
                                }
                            }
                        }
                    }
                },
                tf = function(t) {
                    return void 0 === t && (t = {}), {
                        name: "shift",
                        options: t,
                        async fn(e) {
                            let {
                                x: n,
                                y: r,
                                placement: l
                            } = e, {
                                mainAxis: f = !0,
                                crossAxis: a = !1,
                                limiter: u = {
                                    fn: t => {
                                        let {
                                            x: e,
                                            y: n
                                        } = t;
                                        return {
                                            x: e,
                                            y: n
                                        }
                                    }
                                },
                                ...s
                            } = c(t, e), p = {
                                x: n,
                                y: r
                            }, g = await A(e, s), y = m(d(l)), w = h(y), x = p[w], v = p[y];
                            if (f) {
                                let t = "y" === w ? "top" : "left",
                                    e = "y" === w ? "bottom" : "right",
                                    n = x + g[t],
                                    r = x - g[e];
                                x = o(n, i(x, r))
                            }
                            if (a) {
                                let t = "y" === y ? "top" : "left",
                                    e = "y" === y ? "bottom" : "right",
                                    n = v + g[t],
                                    r = v - g[e];
                                v = o(n, i(v, r))
                            }
                            let b = u.fn({ ...e,
                                [w]: x,
                                [y]: v
                            });
                            return { ...b,
                                data: {
                                    x: b.x - n,
                                    y: b.y - r,
                                    enabled: {
                                        [w]: f,
                                        [y]: a
                                    }
                                }
                            }
                        }
                    }
                },
                ta = function(t) {
                    return void 0 === t && (t = {}), {
                        name: "flip",
                        options: t,
                        async fn(e) {
                            var n, r, i, o, l;
                            let {
                                placement: f,
                                middlewareData: a,
                                rects: u,
                                initialPlacement: s,
                                platform: x,
                                elements: v
                            } = e, {
                                mainAxis: b = !0,
                                crossAxis: R = !0,
                                fallbackPlacements: T,
                                fallbackStrategy: E = "bestFit",
                                fallbackAxisSideDirection: C = "none",
                                flipAlignment: L = !0,
                                ...S
                            } = c(t, e);
                            if (null != (n = a.arrow) && n.alignmentOffset) return {};
                            let O = d(f),
                                P = m(s),
                                D = d(s) === s,
                                k = await (null == x.isRTL ? void 0 : x.isRTL(v.floating)),
                                H = T || (D || !L ? [w(s)] : function(t) {
                                    let e = w(t);
                                    return [y(t), e, y(e)]
                                }(s)),
                                W = "none" !== C;
                            !T && W && H.push(... function(t, e, n, r) {
                                let i = p(t),
                                    o = function(t, e, n) {
                                        let r = ["left", "right"],
                                            i = ["right", "left"];
                                        switch (t) {
                                            case "top":
                                            case "bottom":
                                                if (n) return e ? i : r;
                                                return e ? r : i;
                                            case "left":
                                            case "right":
                                                return e ? ["top", "bottom"] : ["bottom", "top"];
                                            default:
                                                return []
                                        }
                                    }(d(t), "start" === n, r);
                                return i && (o = o.map(t => t + "-" + i), e && (o = o.concat(o.map(y)))), o
                            }(s, L, C, k));
                            let F = [s, ...H],
                                M = await A(e, S),
                                j = [],
                                $ = (null == (r = a.flip) ? void 0 : r.overflows) || [];
                            if (b && j.push(M[O]), R) {
                                let t = function(t, e, n) {
                                    void 0 === n && (n = !1);
                                    let r = p(t),
                                        i = h(m(t)),
                                        o = g(i),
                                        l = "x" === i ? r === (n ? "end" : "start") ? "right" : "left" : "start" === r ? "bottom" : "top";
                                    return e.reference[o] > e.floating[o] && (l = w(l)), [l, w(l)]
                                }(f, u, k);
                                j.push(M[t[0]], M[t[1]])
                            }
                            if ($ = [...$, {
                                    placement: f,
                                    overflows: j
                                }], !j.every(t => t <= 0)) {
                                let t = ((null == (i = a.flip) ? void 0 : i.index) || 0) + 1,
                                    e = F[t];
                                if (e) return {
                                    data: {
                                        index: t,
                                        overflows: $
                                    },
                                    reset: {
                                        placement: e
                                    }
                                };
                                let n = null == (o = $.filter(t => t.overflows[0] <= 0).sort((t, e) => t.overflows[1] - e.overflows[1])[0]) ? void 0 : o.placement;
                                if (!n) switch (E) {
                                    case "bestFit":
                                        {
                                            let t = null == (l = $.filter(t => {
                                                if (W) {
                                                    let e = m(t.placement);
                                                    return e === P || "y" === e
                                                }
                                                return !0
                                            }).map(t => [t.placement, t.overflows.filter(t => t > 0).reduce((t, e) => t + e, 0)]).sort((t, e) => t[1] - e[1])[0]) ? void 0 : l[0];t && (n = t);
                                            break
                                        }
                                    case "initialPlacement":
                                        n = s
                                }
                                if (f !== n) return {
                                    reset: {
                                        placement: n
                                    }
                                }
                            }
                            return {}
                        }
                    }
                },
                tu = function(t) {
                    return void 0 === t && (t = {}), {
                        name: "size",
                        options: t,
                        async fn(e) {
                            var n, r;
                            let l, f;
                            let {
                                placement: a,
                                rects: u,
                                platform: s,
                                elements: h
                            } = e, {
                                apply: g = () => {},
                                ...y
                            } = c(t, e), w = await A(e, y), x = d(a), v = p(a), b = "y" === m(a), {
                                width: R,
                                height: T
                            } = u.floating;
                            "top" === x || "bottom" === x ? (l = x, f = v === (await (null == s.isRTL ? void 0 : s.isRTL(h.floating)) ? "start" : "end") ? "left" : "right") : (f = x, l = "end" === v ? "top" : "bottom");
                            let E = T - w.top - w.bottom,
                                C = R - w.left - w.right,
                                L = i(T - w[l], E),
                                S = i(R - w[f], C),
                                O = !e.middlewareData.shift,
                                P = L,
                                D = S;
                            if (null != (n = e.middlewareData.shift) && n.enabled.x && (D = C), null != (r = e.middlewareData.shift) && r.enabled.y && (P = E), O && !v) {
                                let t = o(w.left, 0),
                                    e = o(w.right, 0),
                                    n = o(w.top, 0),
                                    r = o(w.bottom, 0);
                                b ? D = R - 2 * (0 !== t || 0 !== e ? t + e : o(w.left, w.right)) : P = T - 2 * (0 !== n || 0 !== r ? n + r : o(w.top, w.bottom))
                            }
                            await g({ ...e,
                                availableWidth: D,
                                availableHeight: P
                            });
                            let k = await s.getDimensions(h.floating);
                            return R !== k.width || T !== k.height ? {
                                reset: {
                                    rects: !0
                                }
                            } : {}
                        }
                    }
                },
                ts = function(t) {
                    return void 0 === t && (t = {}), {
                        name: "hide",
                        options: t,
                        async fn(e) {
                            let {
                                rects: n
                            } = e, {
                                strategy: r = "referenceHidden",
                                ...i
                            } = c(t, e);
                            switch (r) {
                                case "referenceHidden":
                                    {
                                        let t = T(await A(e, { ...i,
                                            elementContext: "reference"
                                        }), n.reference);
                                        return {
                                            data: {
                                                referenceHiddenOffsets: t,
                                                referenceHidden: E(t)
                                            }
                                        }
                                    }
                                case "escaped":
                                    {
                                        let t = T(await A(e, { ...i,
                                            altBoundary: !0
                                        }), n.floating);
                                        return {
                                            data: {
                                                escapedOffsets: t,
                                                escaped: E(t)
                                            }
                                        }
                                    }
                                default:
                                    return {}
                            }
                        }
                    }
                },
                tc = t => ({
                    name: "arrow",
                    options: t,
                    async fn(e) {
                        let {
                            x: n,
                            y: r,
                            placement: l,
                            rects: f,
                            platform: a,
                            elements: u,
                            middlewareData: s
                        } = e, {
                            element: d,
                            padding: y = 0
                        } = c(t, e) || {};
                        if (null == d) return {};
                        let w = x(y),
                            v = {
                                x: n,
                                y: r
                            },
                            b = h(m(l)),
                            R = g(b),
                            A = await a.getDimensions(d),
                            T = "y" === b,
                            E = T ? "clientHeight" : "clientWidth",
                            C = f.reference[R] + f.reference[b] - v[b] - f.floating[R],
                            L = v[b] - f.reference[b],
                            S = await (null == a.getOffsetParent ? void 0 : a.getOffsetParent(d)),
                            O = S ? S[E] : 0;
                        O && await (null == a.isElement ? void 0 : a.isElement(S)) || (O = u.floating[E] || f.floating[R]);
                        let P = O / 2 - A[R] / 2 - 1,
                            D = i(w[T ? "top" : "left"], P),
                            k = i(w[T ? "bottom" : "right"], P),
                            H = O - A[R] - k,
                            W = O / 2 - A[R] / 2 + (C / 2 - L / 2),
                            F = o(D, i(W, H)),
                            M = !s.arrow && null != p(l) && W !== F && f.reference[R] / 2 - (W < D ? D : k) - A[R] / 2 < 0,
                            j = M ? W < D ? W - D : W - H : 0;
                        return {
                            [b]: v[b] + j,
                            data: {
                                [b]: F,
                                centerOffset: W - F - j,
                                ...M && {
                                    alignmentOffset: j
                                }
                            },
                            reset: M
                        }
                    }
                }),
                td = function(t) {
                    return void 0 === t && (t = {}), {
                        options: t,
                        fn(e) {
                            let {
                                x: n,
                                y: r,
                                placement: i,
                                rects: o,
                                middlewareData: l
                            } = e, {
                                offset: f = 0,
                                mainAxis: a = !0,
                                crossAxis: u = !0
                            } = c(t, e), s = {
                                x: n,
                                y: r
                            }, p = m(i), g = h(p), y = s[g], w = s[p], x = c(f, e), v = "number" == typeof x ? {
                                mainAxis: x,
                                crossAxis: 0
                            } : {
                                mainAxis: 0,
                                crossAxis: 0,
                                ...x
                            };
                            if (a) {
                                let t = "y" === g ? "height" : "width",
                                    e = o.reference[g] - o.floating[t] + v.mainAxis,
                                    n = o.reference[g] + o.reference[t] - v.mainAxis;
                                y < e ? y = e : y > n && (y = n)
                            }
                            if (u) {
                                var b, R;
                                let t = "y" === g ? "width" : "height",
                                    e = ["top", "left"].includes(d(i)),
                                    n = o.reference[p] - o.floating[t] + (e && (null == (b = l.offset) ? void 0 : b[p]) || 0) + (e ? 0 : v.crossAxis),
                                    r = o.reference[p] + o.reference[t] + (e ? 0 : (null == (R = l.offset) ? void 0 : R[p]) || 0) - (e ? v.crossAxis : 0);
                                w < n ? w = n : w > r && (w = r)
                            }
                            return {
                                [g]: y,
                                [p]: w
                            }
                        }
                    }
                },
                tp = (t, e, n) => {
                    let r = new Map,
                        i = {
                            platform: ti,
                            ...n
                        },
                        o = { ...i.platform,
                            _c: r
                        };
                    return R(t, e, { ...i,
                        platform: o
                    })
                }
        },
        5157: function(t, e, n) {
            "use strict";
            n.d(e, {
                Cp: function() {
                    return w
                },
                RR: function() {
                    return m
                },
                YF: function() {
                    return c
                },
                cv: function() {
                    return p
                },
                dp: function() {
                    return y
                },
                dr: function() {
                    return g
                },
                uY: function() {
                    return h
                },
                x7: function() {
                    return x
                }
            });
            var r = n(45505),
                i = n(7653),
                o = n(3458),
                l = "undefined" != typeof document ? i.useLayoutEffect : i.useEffect;

            function f(t, e) {
                let n, r, i;
                if (t === e) return !0;
                if (typeof t != typeof e) return !1;
                if ("function" == typeof t && t.toString() === e.toString()) return !0;
                if (t && e && "object" == typeof t) {
                    if (Array.isArray(t)) {
                        if ((n = t.length) !== e.length) return !1;
                        for (r = n; 0 != r--;)
                            if (!f(t[r], e[r])) return !1;
                        return !0
                    }
                    if ((n = (i = Object.keys(t)).length) !== Object.keys(e).length) return !1;
                    for (r = n; 0 != r--;)
                        if (!({}).hasOwnProperty.call(e, i[r])) return !1;
                    for (r = n; 0 != r--;) {
                        let n = i[r];
                        if (("_owner" !== n || !t.$$typeof) && !f(t[n], e[n])) return !1
                    }
                    return !0
                }
                return t != t && e != e
            }

            function a(t) {
                return "undefined" == typeof window ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1
            }

            function u(t, e) {
                let n = a(t);
                return Math.round(e * n) / n
            }

            function s(t) {
                let e = i.useRef(t);
                return l(() => {
                    e.current = t
                }), e
            }

            function c(t) {
                void 0 === t && (t = {});
                let {
                    placement: e = "bottom",
                    strategy: n = "absolute",
                    middleware: c = [],
                    platform: d,
                    elements: {
                        reference: p,
                        floating: h
                    } = {},
                    transform: g = !0,
                    whileElementsMounted: m,
                    open: y
                } = t, [w, x] = i.useState({
                    x: 0,
                    y: 0,
                    strategy: n,
                    placement: e,
                    middlewareData: {},
                    isPositioned: !1
                }), [v, b] = i.useState(c);
                f(v, c) || b(c);
                let [R, A] = i.useState(null), [T, E] = i.useState(null), C = i.useCallback(t => {
                    t !== P.current && (P.current = t, A(t))
                }, []), L = i.useCallback(t => {
                    t !== D.current && (D.current = t, E(t))
                }, []), S = p || R, O = h || T, P = i.useRef(null), D = i.useRef(null), k = i.useRef(w), H = null != m, W = s(m), F = s(d), M = s(y), j = i.useCallback(() => {
                    if (!P.current || !D.current) return;
                    let t = {
                        placement: e,
                        strategy: n,
                        middleware: v
                    };
                    F.current && (t.platform = F.current), (0, r.oo)(P.current, D.current, t).then(t => {
                        let e = { ...t,
                            isPositioned: !1 !== M.current
                        };
                        $.current && !f(k.current, e) && (k.current = e, o.flushSync(() => {
                            x(e)
                        }))
                    })
                }, [v, e, n, F, M]);
                l(() => {
                    !1 === y && k.current.isPositioned && (k.current.isPositioned = !1, x(t => ({ ...t,
                        isPositioned: !1
                    })))
                }, [y]);
                let $ = i.useRef(!1);
                l(() => ($.current = !0, () => {
                    $.current = !1
                }), []), l(() => {
                    if (S && (P.current = S), O && (D.current = O), S && O) {
                        if (W.current) return W.current(S, O, j);
                        j()
                    }
                }, [S, O, j, W, H]);
                let V = i.useMemo(() => ({
                        reference: P,
                        floating: D,
                        setReference: C,
                        setFloating: L
                    }), [C, L]),
                    z = i.useMemo(() => ({
                        reference: S,
                        floating: O
                    }), [S, O]),
                    N = i.useMemo(() => {
                        let t = {
                            position: n,
                            left: 0,
                            top: 0
                        };
                        if (!z.floating) return t;
                        let e = u(z.floating, w.x),
                            r = u(z.floating, w.y);
                        return g ? { ...t,
                            transform: "translate(" + e + "px, " + r + "px)",
                            ...a(z.floating) >= 1.5 && {
                                willChange: "transform"
                            }
                        } : {
                            position: n,
                            left: e,
                            top: r
                        }
                    }, [n, g, z.floating, w.x, w.y]);
                return i.useMemo(() => ({ ...w,
                    update: j,
                    refs: V,
                    elements: z,
                    floatingStyles: N
                }), [w, j, V, z, N])
            }
            let d = t => ({
                    name: "arrow",
                    options: t,
                    fn(e) {
                        let {
                            element: n,
                            padding: i
                        } = "function" == typeof t ? t(e) : t;
                        return n && ({}).hasOwnProperty.call(n, "current") ? null != n.current ? (0, r.x7)({
                            element: n.current,
                            padding: i
                        }).fn(e) : {} : n ? (0, r.x7)({
                            element: n,
                            padding: i
                        }).fn(e) : {}
                    }
                }),
                p = (t, e) => ({ ...(0, r.cv)(t),
                    options: [t, e]
                }),
                h = (t, e) => ({ ...(0, r.uY)(t),
                    options: [t, e]
                }),
                g = (t, e) => ({ ...(0, r.dr)(t),
                    options: [t, e]
                }),
                m = (t, e) => ({ ...(0, r.RR)(t),
                    options: [t, e]
                }),
                y = (t, e) => ({ ...(0, r.dp)(t),
                    options: [t, e]
                }),
                w = (t, e) => ({ ...(0, r.Cp)(t),
                    options: [t, e]
                }),
                x = (t, e) => ({ ...d(t),
                    options: [t, e]
                })
        },
        73222: function(t, e, n) {
            "use strict";
            n.d(e, {
                ee: function() {
                    return k
                },
                Eh: function() {
                    return W
                },
                VY: function() {
                    return H
                },
                fC: function() {
                    return D
                },
                D7: function() {
                    return g
                }
            });
            var r = n(7653),
                i = n(5157),
                o = n(45505),
                l = n(62744),
                f = n(27573),
                a = r.forwardRef((t, e) => {
                    let {
                        children: n,
                        width: r = 10,
                        height: i = 5,
                        ...o
                    } = t;
                    return (0, f.jsx)(l.WV.svg, { ...o,
                        ref: e,
                        width: r,
                        height: i,
                        viewBox: "0 0 30 10",
                        preserveAspectRatio: "none",
                        children: t.asChild ? n : (0, f.jsx)("polygon", {
                            points: "0,0 30,0 15,10"
                        })
                    })
                });
            a.displayName = "Arrow";
            var u = n(52925),
                s = n(94821),
                c = n(58876),
                d = n(89874),
                p = "Popper",
                [h, g] = (0, s.b)(p),
                [m, y] = h(p),
                w = t => {
                    let {
                        __scopePopper: e,
                        children: n
                    } = t, [i, o] = r.useState(null);
                    return (0, f.jsx)(m, {
                        scope: e,
                        anchor: i,
                        onAnchorChange: o,
                        children: n
                    })
                };
            w.displayName = p;
            var x = "PopperAnchor",
                v = r.forwardRef((t, e) => {
                    let {
                        __scopePopper: n,
                        virtualRef: i,
                        ...o
                    } = t, a = y(x, n), s = r.useRef(null), c = (0, u.e)(e, s);
                    return r.useEffect(() => {
                        a.onAnchorChange(i ? .current || s.current)
                    }), i ? null : (0, f.jsx)(l.WV.div, { ...o,
                        ref: c
                    })
                });
            v.displayName = x;
            var b = "PopperContent",
                [R, A] = h(b),
                T = r.forwardRef((t, e) => {
                    let {
                        __scopePopper: n,
                        side: a = "bottom",
                        sideOffset: s = 0,
                        align: p = "center",
                        alignOffset: h = 0,
                        arrowPadding: g = 0,
                        avoidCollisions: m = !0,
                        collisionBoundary: w = [],
                        collisionPadding: x = 0,
                        sticky: v = "partial",
                        hideWhenDetached: A = !1,
                        updatePositionStrategy: T = "optimized",
                        onPlaced: E,
                        ...C
                    } = t, L = y(b, n), [D, k] = r.useState(null), H = (0, u.e)(e, t => k(t)), [W, F] = r.useState(null), M = function(t) {
                        let [e, n] = r.useState(void 0);
                        return (0, d.b)(() => {
                            if (t) {
                                n({
                                    width: t.offsetWidth,
                                    height: t.offsetHeight
                                });
                                let e = new ResizeObserver(e => {
                                    let r, i;
                                    if (!Array.isArray(e) || !e.length) return;
                                    let o = e[0];
                                    if ("borderBoxSize" in o) {
                                        let t = o.borderBoxSize,
                                            e = Array.isArray(t) ? t[0] : t;
                                        r = e.inlineSize, i = e.blockSize
                                    } else r = t.offsetWidth, i = t.offsetHeight;
                                    n({
                                        width: r,
                                        height: i
                                    })
                                });
                                return e.observe(t, {
                                    box: "border-box"
                                }), () => e.unobserve(t)
                            }
                            n(void 0)
                        }, [t]), e
                    }(W), j = M ? .width ? ? 0, $ = M ? .height ? ? 0, V = "number" == typeof x ? x : {
                        top: 0,
                        right: 0,
                        bottom: 0,
                        left: 0,
                        ...x
                    }, z = Array.isArray(w) ? w : [w], N = z.length > 0, Y = {
                        padding: V,
                        boundary: z.filter(S),
                        altBoundary: N
                    }, {
                        refs: B,
                        floatingStyles: _,
                        placement: I,
                        isPositioned: X,
                        middlewareData: q
                    } = (0, i.YF)({
                        strategy: "fixed",
                        placement: a + ("center" !== p ? "-" + p : ""),
                        whileElementsMounted: function() {
                            for (var t = arguments.length, e = Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                            return (0, o.Me)(...e, {
                                animationFrame: "always" === T
                            })
                        },
                        elements: {
                            reference: L.anchor
                        },
                        middleware: [(0, i.cv)({
                            mainAxis: s + $,
                            alignmentAxis: h
                        }), m && (0, i.uY)({
                            mainAxis: !0,
                            crossAxis: !1,
                            limiter: "partial" === v ? (0, i.dr)() : void 0,
                            ...Y
                        }), m && (0, i.RR)({ ...Y
                        }), (0, i.dp)({ ...Y,
                            apply: t => {
                                let {
                                    elements: e,
                                    rects: n,
                                    availableWidth: r,
                                    availableHeight: i
                                } = t, {
                                    width: o,
                                    height: l
                                } = n.reference, f = e.floating.style;
                                f.setProperty("--radix-popper-available-width", `${r}px`), f.setProperty("--radix-popper-available-height", `${i}px`), f.setProperty("--radix-popper-anchor-width", `${o}px`), f.setProperty("--radix-popper-anchor-height", `${l}px`)
                            }
                        }), W && (0, i.x7)({
                            element: W,
                            padding: g
                        }), O({
                            arrowWidth: j,
                            arrowHeight: $
                        }), A && (0, i.Cp)({
                            strategy: "referenceHidden",
                            ...Y
                        })]
                    }), [G, J] = P(I), K = (0, c.W)(E);
                    (0, d.b)(() => {
                        X && K ? .()
                    }, [X, K]);
                    let Q = q.arrow ? .x,
                        U = q.arrow ? .y,
                        Z = q.arrow ? .centerOffset !== 0,
                        [tt, te] = r.useState();
                    return (0, d.b)(() => {
                        D && te(window.getComputedStyle(D).zIndex)
                    }, [D]), (0, f.jsx)("div", {
                        ref: B.setFloating,
                        "data-radix-popper-content-wrapper": "",
                        style: { ..._,
                            transform: X ? _.transform : "translate(0, -200%)",
                            minWidth: "max-content",
                            zIndex: tt,
                            "--radix-popper-transform-origin": [q.transformOrigin ? .x, q.transformOrigin ? .y].join(" "),
                            ...q.hide ? .referenceHidden && {
                                visibility: "hidden",
                                pointerEvents: "none"
                            }
                        },
                        dir: t.dir,
                        children: (0, f.jsx)(R, {
                            scope: n,
                            placedSide: G,
                            onArrowChange: F,
                            arrowX: Q,
                            arrowY: U,
                            shouldHideArrow: Z,
                            children: (0, f.jsx)(l.WV.div, {
                                "data-side": G,
                                "data-align": J,
                                ...C,
                                ref: H,
                                style: { ...C.style,
                                    animation: X ? void 0 : "none"
                                }
                            })
                        })
                    })
                });
            T.displayName = b;
            var E = "PopperArrow",
                C = {
                    top: "bottom",
                    right: "left",
                    bottom: "top",
                    left: "right"
                },
                L = r.forwardRef(function(t, e) {
                    let {
                        __scopePopper: n,
                        ...r
                    } = t, i = A(E, n), o = C[i.placedSide];
                    return (0, f.jsx)("span", {
                        ref: i.onArrowChange,
                        style: {
                            position: "absolute",
                            left: i.arrowX,
                            top: i.arrowY,
                            [o]: 0,
                            transformOrigin: {
                                top: "",
                                right: "0 0",
                                bottom: "center 0",
                                left: "100% 0"
                            }[i.placedSide],
                            transform: {
                                top: "translateY(100%)",
                                right: "translateY(50%) rotate(90deg) translateX(-50%)",
                                bottom: "rotate(180deg)",
                                left: "translateY(50%) rotate(-90deg) translateX(50%)"
                            }[i.placedSide],
                            visibility: i.shouldHideArrow ? "hidden" : void 0
                        },
                        children: (0, f.jsx)(a, { ...r,
                            ref: e,
                            style: { ...r.style,
                                display: "block"
                            }
                        })
                    })
                });

            function S(t) {
                return null !== t
            }
            L.displayName = E;
            var O = t => ({
                name: "transformOrigin",
                options: t,
                fn(e) {
                    let {
                        placement: n,
                        rects: r,
                        middlewareData: i
                    } = e, o = i.arrow ? .centerOffset !== 0, l = o ? 0 : t.arrowWidth, f = o ? 0 : t.arrowHeight, [a, u] = P(n), s = {
                        start: "0%",
                        center: "50%",
                        end: "100%"
                    }[u], c = (i.arrow ? .x ? ? 0) + l / 2, d = (i.arrow ? .y ? ? 0) + f / 2, p = "", h = "";
                    return "bottom" === a ? (p = o ? s : `${c}px`, h = `${-f}px`) : "top" === a ? (p = o ? s : `${c}px`, h = `${r.floating.height+f}px`) : "right" === a ? (p = `${-f}px`, h = o ? s : `${d}px`) : "left" === a && (p = `${r.floating.width+f}px`, h = o ? s : `${d}px`), {
                        data: {
                            x: p,
                            y: h
                        }
                    }
                }
            });

            function P(t) {
                let [e, n = "center"] = t.split("-");
                return [e, n]
            }
            var D = w,
                k = v,
                H = T,
                W = L
        }
    }
]);